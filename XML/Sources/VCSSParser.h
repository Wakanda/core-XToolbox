/*
* This file is part of Wakanda software, licensed by 4D under
*  (i) the GNU General Public License version 3 (GNU GPL v3), or
*  (ii) the Affero General Public License version 3 (AGPL v3) or
*  (iii) a commercial license.
* This file remains the exclusive property of 4D and/or its licensors
* and is protected by national and international legislations.
* In any event, Licensee's compliance with the terms and conditions
* of the applicable license constitutes a prerequisite to any use of this file.
* Except as otherwise expressly stated in the applicable license,
* such license does not include any other license or rights on this file,
* 4D's and/or its licensors' trademarks and/or other proprietary rights.
* Consequently, no title, copyright or other proprietary rights
* other than those specified in the applicable license is granted.
*/
/** CSS2 parser + matcher

	lexical/syntaxic CSS parser is CSS2 compliant with some constraints:
	- property values - either ident/string/number/dimension/percentage/etc... - are correctly tokenized 
	   but by default any property value is stored as a string no matter the property value type : 
	   in that case, if property value is complex - for instance a dimension value with a number and a ident  - 
	   syntaxic parser will concatenate token values with consolidated delimitors to build the resulting property value string
	   (for instance for declaration "font: 12pt, bold ;" property value string will be "12pt"+","+"bold" = "12pt,bold")
	- now parser can optionally pre-parse most CSS2 & SVG attributes (see CSSProperty::eType): 
	  for that use VCSSParser::SetMapAttributeType to initialize the mapping between properties names & properties types and
	  the VCSSMatch callback VCSSMatch::SetHandlerSetAttribute will now return the parsed value if any 
	  as a CSSProperty::Value instance as well as the unparsed value as a VString
	  (so parser client can still parse the value if it has specific syntax for some attributes)
	- universal, type, class, attribute, ID, descendant, child and adjacent selectors are fully supported 
	- only :first-child and :lang({ident}) pseudo-classes selectors are fully supported: 
	  other pseudo-classes selectors are parsed and related rules returned by parser too
	  but rules are ignored by the provided matching algorithm
	- !important symbol is supported (note that by default, CSS styles do not override attributes 
	   that are explicitely set - not inherited - by a matching element so you must use !important symbol if you want 
	   a CSS style to override matching element attribute especially if it is explicitely set)
	- expressions and counters are not supported by syntaxic parser (but rule will store the string value)
	- functions are not supported by syntaxic parser (but rule will store the string value)
	- <!-- and --> tokens are parsed/skipped for compatibility but not used: use comments if you want to comment some rulesets or declarations
	- only @import and @media at-rules are supported: other at-rules are ignored
	  (for @media at-rule, only 'print', 'screen' and 'all' are supported - other medias rules are ignored)

    CSS matcher class (VCSSMatch) is a tool class that can be used to override CSS matching attributes 
	while parsing xml document or on a per-element basis using CSS rules generated by the CSS parser

	IMPORTANT:	parser and utility classes are ALL used by SVG component
				so if you need to modify it, you should also think about side effects with SVG component
				(to avoid side effects, it is recommended to add extra methods
				than to modify the existing ones when it is possible)

	exceptions:
		CSS parser will throw VCSSException for any lexical/parser error


	usage:
	[code/]

	//init medias filter (optional: default is all)
	CSSMedia::Set medias;
	medias.insert((int)CSSMedia::ALL);

	//init rules
	CSSRuleSet::MediaRules rules;

	//run parser
	VCSSParser *parserCSS = new VCSSParser();
	
	//optionally, we can define mapping between CSS2 or SVG properties & types
	//in order parser to parse property values too

	CSSProperty::MapAttributeType mapValueType;
	parserCSS->SetMapAttributeType( &mapValueType);

	//for instance:
	mapValueType["width"] = CSSProperty::LENGTH;
	mapValueType["height"] = CSSProperty::LENGTH;
	mapValueType["color"] = CSSProperty::COLOR;
	mapValueType["font-family"] = CSSProperty::FONTFAMILY;
	//and so on...
	
	try
	{
		parserCSS->ParseURL( "file:///c:/mystyles_dir/", "mystyles.css", &rules, &medias);

		//or
		//parserCSS->Parse( VString("rect { fill: red }"), "", &rules, &medias);

		//or
		//parserCSS->Parse( VString("@import url(mystyles.css); rect { fill: red }"), "file:///c:/mystyles_dir/", &rules, &medias);


	}
	catch( VCSSException e)
	{
		//deal with parser error
	}
	delete parserCSS;

	//then to check generated rules per element and override matching attributes:
	//
	//before starting dom/sax/custom parsing,
	//construct instance of VCSSMatch
	//and set all VCSSMatch handlers:

	fCSSMatch = new VCSSMatch();
	fCSSMatch->SetCSSRules( &rules);
	fCSSMatch->SetHandlerGetAttributeValue( myGetAttributeValue);
	fCSSMatch->SetHandlerGetElementLangType( myGetElementLangType);
	fCSSMatch->SetHandlerGetElementClass( myGetElementClass);
	fCSSMatch->SetHandlerGetElementName( myGetElementName);
	fCSSMatch->SetHandlerGetParentElement( myGetParentElement);
	fCSSMatch->SetHandlerGetPrevElement( myGetPrevElement);
	fCSSMatch->SetHandlerSetAttribute( mySetAttribute);
	
	//then while parsing xml document, call Match() method for any new parsed element
	//(but after element attributes has been parsed): 
	//(Match() will call SetAttribute handler only for attributes that match CSS styles)

	fCSSMatch->Match( myNodeElement)   

	[/code]
*/

#ifndef __VCSSPARSER__
#define __VCSSPARSER__

#include <set>
#include <vector>
#include <map>

BEGIN_TOOLBOX_NAMESPACE

namespace CSSToken
{
	typedef enum eCSSToken
	{
		IDENT,				//{ident}  
		ATKEYWORD,			//@{ident}  
		STRING,				//{string} 
		HASH,				//#{name}  
		CLASS,				//.{ident}
		PSEUDO_CLASS,		//:{ident}
		NUMBER,				//{num}
		PERCENTAGE,			//{num}%
		DIMENSION,			//{num}{ident}
		FUNCTION,			//{ident}(
		URI,				//url\({w}{string}{w}\) | url\({w}([!#$%&*-~]|{nonascii}|{escape})*{w}\)
		INCLUDES,			//~=  
		DASHMATCH,			//|=  
		CDO,				//<!--  
		CDC,				//--> 
		DOT,				//.
		COMMA,				//,
		COLON,				//:
		SEMI_COLON,			//;  
		LEFT_CURLY_BRACE,	//{  
		RIGHT_CURLY_BRACE,	//}
		LEFT_BRACE,			//(  
		RIGHT_BRACE,		//)  
		LEFT_BRACKET,		//[  
		RIGHT_BRACKET,		//]  
		MINUS,				//-
		PLUS,				//+
		DIV,				///
		MUL,				//*
		GREATER,			//>
		EQUAL,				//=
		S,					//[ \t\r\n\f]+  
		COMMENT,			//\/\*[^*]*\*+([^/][^*]*\*+)*\/  
		IMPORTANT_SYMBOL,	//!important

		DELIM,				//any character not defined by above rules
		END
	} eCSSToken;
}


/** CSS & SVG values types 
@remarks
	used to pre-parse values
*/

namespace CSSProperty
{
	/** CSS Property type definition
	@remarks
		- only positive values are allowed for LENGTH, SVGLENGTH, FONTSIZE & SVGFONTSIZE: 
		  use COORD or SVGCOORD if property value can be negative (like "x" or "y" in SVG)
	   -  LENGTH, COORD, FONTSIZE, SVGLENGTH, SVGCOORD & SVGFONTSIZE actually match both CSS2 <length> & <percentage>
		  because most properties which support <length> support also <percentage>
	      so use fLength.fUnit to know if the parsed value is a percentage or not 
	   -  LENGTH, COORD & FONTSIZE allow only dimension value (number+unit) and percentage
	      while SVGLENGTH, SVGCOORD & SVGFONTSIZE allow single number value too (unit in this case is assumed to be PX)
		  so use LENGTH, COORD & FONTSIZE for strict CSS2 parsing and SVGLENGTH, SVGCOORD & SVGFONTSIZE for SVG parsing
  	*/
	typedef enum eType 
	{
		LENGTH,
		FONTSIZE,
		COORD, /** same as LENGTH but can be negative so can be used for properties which allow negative <length> values */
		STRING,

		LINEHEIGHT,
		NUMBER,
		URI,	/** only CSS2 url is allowed */
		DIMENSION,
		PERCENTAGE,
		DISPLAY,
		VISIBILITY,
		FONTFAMILY,
		FONTSTYLE,
		FONTWEIGHT,
		TEXTDECORATION,
		DIRECTION,
		WRITINGMODE,
		TEXTALIGN,
		DISPLAYALIGN,
		VERTICALALIGN,
		BORDERSTYLE,
		BORDERWIDTH,
		BORDERRADIUS = BORDERWIDTH,
		COLOR, /** 'transparent' & 'invert' ident are allowed, also support SVG color idents */
		BACKGROUNDPOSITION,
		BACKGROUNDREPEAT,
		BACKGROUNDCLIP,
		BACKGROUNDORIGIN,
		BACKGROUNDSIZE,
		TABSTOPTYPE4D, //4D CSS property
		LISTSTYLETYPE, 
		LISTSTYLETYPE4D, //same as regular CSS but with private 4D tokens

		SVGLENGTH, /** same as LENGTH but unit is optional */
		SVGFONTSIZE, /** same as FONTSIZE but unit is optional */
		SVGCOORD, /** same as COORD but unit is optional */

		SVGNUMBER,
		SVGANGLE,
		SVGCOLOR, /** 'currentColor' is allowed but 'transparent' & 'invert' are not allowed */
		SVGPAINT,
		SVGURI,	   /** CSS2 url or SVG URI is allowed */
		SVGFILLRULE,
		SVGOPACITY,
		SVGOFFSET,
		SVGSTROKELINECAP,
		SVGSTROKELINEJOIN,
		SVGTEXTANCHOR,
		SVGSHAPERENDERING,
		SVGTEXTRENDERING,
		SVGTEXTALIGN
		
	} eType;

	//CSS unit types
	typedef enum eUnit
	{
		LENGTH_TYPE_PERCENT,			/* percentage (number range is [0.0, 1.0]) */
		LENGTH_TYPE_PX,					/* pixels */
		LENGTH_TYPE_PC,					/* picas */
		LENGTH_TYPE_PT,					/* points */
		LENGTH_TYPE_MM,					/* millimeters */
		LENGTH_TYPE_CM,					/* centimeters */
		LENGTH_TYPE_IN,					/* inchs */
		LENGTH_TYPE_EM,					/* size of the current font */
		LENGTH_TYPE_EX,					/* x-height of the current font */
		LENGTH_TYPE_FONTSIZE_LARGER,	/* larger than the parent node font size (used by FONTSIZE only) */
		LENGTH_TYPE_FONTSIZE_SMALLER,	/* smaller than the parent node font size (used by FONTSIZE only) */
	} eUnit;

	typedef enum eStrokeLineCap
	{
		kStrokeLineCapButt,
		kStrokeLineCapRound,
		kStrokeLineCapSquare
	} eStrokeLineCap;

	typedef enum eStrokeLineJoin
	{
		kStrokeLineJoinMiter,
		kStrokeLineJoinRound,
		kStrokeLineJoinBevel
	} eStrokeLineJoin;

	typedef enum eFontStyle
	{
		kFONT_STYLE_NORMAL		= 0,
		kFONT_STYLE_ITALIC		= 1,
		kFONT_STYLE_OBLIQUE		= 2,
		kFONT_STYLE_UNDERLINE	= 4,
		kFONT_STYLE_OVERLINE	= 8,	
		kFONT_STYLE_LINETHROUGH	= 16,	//alias 'strikeout' style
		kFONT_STYLE_BLINK		= 32	//remark: not implemented
	} eFontStyle;

	typedef enum eFontWeight
	{
		kFONT_WEIGHT_100 		= 100,
		kFONT_WEIGHT_200 		= 200,
		kFONT_WEIGHT_300 		= 300,
		kFONT_WEIGHT_400 		= 400,
		kFONT_WEIGHT_500 		= 500,
		kFONT_WEIGHT_600 		= 600,
		kFONT_WEIGHT_700 		= 700,
		kFONT_WEIGHT_800 		= 800,
		kFONT_WEIGHT_900 		= 900,

		kFONT_WEIGHT_NORMAL 	= 400,
		kFONT_WEIGHT_BOLD		= 700,

		kFONT_WEIGHT_LIGHTER	= -1,
		kFONT_WEIGHT_BOLDER		= -2,

		kFONT_WEIGHT_MIN		= 100,
		kFONT_WEIGHT_MAX		= 900
	} eFontWeight;	

	#define kFONT_SIZE_XX_SMALL		(12.0-3*0.2*12)
	#define kFONT_SIZE_X_SMALL 		(12.0-2*0.2*12)
	#define kFONT_SIZE_SMALL 		(12.0-1*0.2*12)
	#define kFONT_SIZE_MEDIUM 		(12.0)
	#define kFONT_SIZE_LARGE 		(12.0+1*0.2*12)
	#define kFONT_SIZE_X_LARGE 		(12.0+2*0.2*12)
	#define kFONT_SIZE_XX_LARGE 	(12.0+3*0.2*12)

	/** direction (CSS) */
	typedef enum eDirection
	{
		kDIRECTION_LTR,			//left to right writing mode
		kDIRECTION_RTL,			//right to left writing mode
	} eDirection;

	/** writing*/
	typedef enum eWritingMode
	{
		kWRITING_MODE_LR,			//left to right writing mode
		kWRITING_MODE_RL,			//right to left writing mode
		kWRITING_MODE_TB			//top to bottom writing mode
	} eWritingMode;

	typedef enum eTextAnchor
	{
		kTEXT_ANCHOR_START,				//text brush x coordinate is aligned with left/top text box border
		kTEXT_ANCHOR_MIDDLE,			//text brush x coordinate is aligned with text box middle point
		kTEXT_ANCHOR_END				//text brush x coordinate is aligned with right/bottom text box border
	} eTextAnchor;

	//text align enums 
	typedef enum eTextAlign
	{
		kTEXT_ALIGN_START,			//text aligned to left
		kTEXT_ALIGN_END,			//text aligned to right
		kTEXT_ALIGN_CENTER,			//text centered
		kTEXT_ALIGN_JUSTIFY,		//text justified
		kTEXT_ALIGN_LEFT = kTEXT_ALIGN_START, //text aligned to left
		kTEXT_ALIGN_RIGHT = kTEXT_ALIGN_END //text aligned to right
	} eTextAlign;

	typedef enum eVerticalAlign
	{
		kVERTICAL_ALIGN_BASELINE,		
		kVERTICAL_ALIGN_SUB,		
		kVERTICAL_ALIGN_SUPER,		
		kVERTICAL_ALIGN_TOP,		
		kVERTICAL_ALIGN_TEXT_TOP,		
		kVERTICAL_ALIGN_MIDDLE,
		kVERTICAL_ALIGN_BOTTOM,		
		kVERTICAL_ALIGN_TEXT_BOTTOM		
	} eVerticalAlign;

	/** border style (CSS) */
	typedef enum eBorderStyle
	{
		kBORDER_STYLE_NONE = 0,
		kBORDER_STYLE_HIDDEN,
		kBORDER_STYLE_DOTTED,
		kBORDER_STYLE_DASHED,
		kBORDER_STYLE_SOLID,
		kBORDER_STYLE_DOUBLE,
		kBORDER_STYLE_GROOVE,
		kBORDER_STYLE_RIDGE,
		kBORDER_STYLE_INSET,
		kBORDER_STYLE_OUTSET
	} eBorderStyle;

	typedef enum eShapeRenderingMode
	{
		kSRM_AUTO,
		kSRM_OPTIMIZE_SPEED,
		kSRM_CRISP_EDGES,					/* for now implemented as auto */
		kSRM_GEOMETRIC_PRECISION			/* for now implemented as auto */

	} eShapeRenderingMode;


	typedef enum eTextRenderingMode
	{
		kTRM_AUTO,
		kTRM_OPTIMIZE_SPEED,
		kTRM_OPTIMIZE_LEGIBILITY,			/* for now implemented as auto */
		kTRM_GEOMETRIC_PRECISION			/* for now implemented as auto */

	} eTextRenderingMode;

	typedef enum eBackgroundRepeat
	{
		kBR_REPEAT		=	0,
		kBR_REPEAT_X,
		kBR_REPEAT_Y,
		kBR_NO_REPEAT

	} eBackgroundRepeat;


	typedef enum eBackgroundBox
	{
		kBB_BORDER_BOX	=	0,
		kBB_PADDING_BOX,
		kBB_CONTENT_BOX

	} eBackgroundBox;

	typedef enum eBackgroundSize
	{
		kBS_AUTO		=	0,
		kBS_COVER		=	-10000,
		kBS_CONTAIN		=	-10001

	} eBackgroundSize;

	typedef enum eTabStopType
	{
		kTST_LEFT,
		kTST_RIGHT,
		kTST_CENTER,
		kTST_DECIMAL,
		kTST_BAR
	} eTabStopType;

	/** list style type */
	typedef enum eListStyleType
	{
		kLIST_STYLE_TYPE_NONE = 0,
		kLIST_STYLE_TYPE_DISC,
		kLIST_STYLE_TYPE_CIRCLE,
		kLIST_STYLE_TYPE_SQUARE,

		kLIST_STYLE_TYPE_HOLLOW_SQUARE, //4D reserved
		kLIST_STYLE_TYPE_DIAMOND,		//4D reserved
		kLIST_STYLE_TYPE_CLUB,			//4D reserved
		kLIST_STYLE_TYPE_CUSTOM,		//4D reserved
		
		kLIST_STYLE_TYPE_DECIMAL,
		kLIST_STYLE_TYPE_DECIMAL_LEADING_ZERO,
		kLIST_STYLE_TYPE_LOWER_LATIN,
		kLIST_STYLE_TYPE_LOWER_ROMAN,
		kLIST_STYLE_TYPE_UPPER_LATIN,
		kLIST_STYLE_TYPE_UPPER_ROMAN,
		kLIST_STYLE_TYPE_LOWER_GREEK,
		kLIST_STYLE_TYPE_ARMENIAN,
		kLIST_STYLE_TYPE_GEORGIAN,
		kLIST_STYLE_TYPE_HEBREW,
		kLIST_STYLE_TYPE_HIRAGANA,
		kLIST_STYLE_TYPE_KATAKANA,
		kLIST_STYLE_TYPE_CJK_IDEOGRAPHIC,

		kLIST_STYLE_TYPE_DECIMAL_GREEK	//4D reserved

	} eListStyleType;

	typedef struct Dimension 
	{
		Real fNumber;
		VString *fIdent;
	} Dimension;

	typedef struct Length
	{
		bool fAuto;
		Real fNumber;
		eUnit fUnit;
	} Length;

	typedef struct Color
	{
		bool fTransparent;
		bool fInvert;
		uLONG fColor;
	} Color;

	typedef struct SVGNumber
	{
		bool fAuto;
		Real fNumber;
	} SVGNumber;

	typedef struct SVGPaint
	{
		bool fNone;
		bool fCurrentColor;
		uLONG fColor;
		VString *fURI;
	} SVGPaint;

	typedef struct SVGUri
	{
		bool fNone;
		VString *fURI;
	} SVGUri;

	typedef struct BackgroundSize
	{
		eBackgroundSize fPreset;
		Length fWidth;
		Length fHeight;
	} BackgroundSize;

	typedef struct BackgroundPosition
	{
		eTextAlign fTextAlign;
		eVerticalAlign fVerticalAlign;
	} BackgroundPosition;

	/** class CSSProperty::Value
	@remarks
		polymorph value class used to store pre-parsed CSS values */
	class Value : public IRefCountable
	{
	public: 
		Value() 
		{
			fType = NUMBER;
			v.css.fNumber = 0.0;
		}
		virtual ~Value()
		{
			/** free VString ref if appropriate */
			switch( fType)
			{
			case URI:
				if (v.css.fURI) 
					delete v.css.fURI;
				break;
			case STRING:
				if (v.css.fString) 
					delete v.css.fString;
				break;
			case DIMENSION:
				if (v.css.fDimension.fIdent) 
					delete v.css.fDimension.fIdent;
				break;
			case SVGCOLOR:
			case SVGPAINT:
				if (v.svg.fPaint.fURI) 
					delete v.svg.fPaint.fURI;
				break;
			case SVGURI:
				if (v.svg.fURI.fURI) 
					delete v.svg.fURI.fURI;
				break;
			case FONTFAMILY:
				if (v.css.fFontFamily)
					delete v.css.fFontFamily;
				break;
			default:
				break;
			}
		}
	public:
		/** value type */
		eType fType;
		bool fInherit;

		union 
		{
			/** CSS2 values types */
			union 
			{
				Real fNumber;
				VString *fString;
				VString *fURI;
				Dimension fDimension;
				Real fPercentage; /** percentage range is [0,1] */
				Length fLength; /** used by both LENGTH & COORD & FONTSIZE & BORDERWIDTH */
				Color fColor;
				bool fDisplay;
				bool fVisibility;
				VectorOfVString *fFontFamily;
				eFontStyle fFontStyle;
				uLONG fTextDecoration;
				eFontWeight fFontWeight;
				eDirection fDirection;
				eWritingMode fWritingMode;
				eTextAlign fTextAlign;	/** text horizontal alignment */
				eTextAlign fDisplayAlign;	/** display-align */
				eVerticalAlign fVerticalAlign; /** vertical-align */
				eTabStopType fTabStopType;
				eBorderStyle fBorderStyle; /** border-style */
				BackgroundPosition fBackgroundPosition;
				eBackgroundRepeat fBackgroundRepeat;
				eBackgroundBox fBackgroundClip;
				eBackgroundBox fBackgroundOrigin;
				BackgroundSize fBackgroundSize;
				eListStyleType fListStyleType;
			} css;

			/** SVG values types */
			union
			{
				SVGNumber fNumber; /** used by both SVGNUMBER, SVGOPACITY, SVGOFFSET & SVGANGLE (computed angle in degree) */
				SVGPaint fPaint; /** used by both SVGCOLOR & SVGPAINT types */
				SVGUri fURI;
				Length fLength; /** used by both SVGLENGTH, SVGCOORD & SVGFONTSIZE */
				bool fFillRuleEvenOdd;
				eStrokeLineCap fStrokeLineCap;
				eStrokeLineJoin fStrokeLineJoin;
				eTextAnchor fTextAnchor;
				eShapeRenderingMode fShapeRenderingMode;
				eTextRenderingMode fTextRenderingMode;
			} svg;
		} v;
	};

	/** map of value type per attribute name */
	typedef STL_EXT_NAMESPACE::hash_map<XBOX::VString, eType, STL_EXT_NAMESPACE::STL_HASH_FUNCTOR_NAME<XBOX::VString> >	MapAttributeType;
}


XTOOLBOX_API extern const VString kCSS_UNIT_PERCENT;

//predefined colors

XTOOLBOX_API extern const VString kCSS_XML_COLOR_ALICEBLUE				;		
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ANTIQUEWHITE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_AQUA					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_AQUAMARINE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_AZURE					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BEIGE					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BISQUE					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BLACK					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BLANCHEDALMOND			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BLUE					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BLUEVIOLET				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BROWN					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_BURLYWOOD				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CADETBLUE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CHARTREUSE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CHOCOLATE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CORAL					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CORNFLOWERBLUE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CORNSILK				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CRIMSON				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_CYAN					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKBLUE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKCYAN				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKGOLDENROD			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKGRAY				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKGREEN				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKGREY				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKKHAKI				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKMAGENTA			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKOLIVEGREEN			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKORANGE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKORCHID				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKRED				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKSALMON				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKSEAGREEN			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKSLATEBLUE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKSLATEGRAY			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKSLATEGREY			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKTURQUOISE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DARKVIOLET				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DEEPPINK				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DEEPSKYBLUE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DIMGRAY				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DIMGREY				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_DODGERBLUE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_FIREBRICK				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_FLORALWHITE			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_FORESTGREEN			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_FUCHSIA				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GAINSBORO				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GHOSTWHITE				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GOLD					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GOLDENROD				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GRAY					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GREY					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GREEN					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_GREENYELLOW			;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_HONEYDEW				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_HOTPINK				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_INDIANRED				;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_INDIGO					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_IVORY					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_KHAKI					;	
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LAVENDER				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LAVENDERBLUSH			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LAWNGREEN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LEMONCHIFFON			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTCORAL				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTCYAN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTGOLDENRODYELLOW	;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTGRAY				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTGREEN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTGREY				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTPINK				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSALMON			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSEAGREEN			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSKYBLUE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSLATEGRAY			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSLATEGREY			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTSTEELBLUE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIGHTYELLOW			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIME					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LIMEGREEN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_LINEN					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MAGENTA				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MAROON					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMAQUAMARINE		;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMORCHID			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMPURPLE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMSEAGREEN			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMSLATEBLUE		;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMSPRINGGREEN		;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMTURQUOISE		;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MEDIUMVIOLETRED		;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MIDNIGHTBLUE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MINTCREAM				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MISTYROSE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_MOCCASIN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_NAVAJOWHITE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_NAVY					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_OLDLACE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_OLIVE					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_OLIVEDRAB				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ORANGE					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ORANGERED				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ORCHID					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PALEGOLDENROD			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PALEGREEN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PALETURQUOISE			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PALEVIOLETRED			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PAPAYAWHIP				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PEACHPUFF				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PERU					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PINK					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PLUM					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_POWDERBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_PURPLE					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_RED					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ROSYBROWN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_ROYALBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SADDLEBROWN			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SALMON					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SANDYBROWN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SEAGREEN				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SEASHELL				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SIENNA					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SILVER					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SKYBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SLATEBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SLATEGRAY				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SLATEGREY				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SNOW					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_SPRINGGREEN			;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_STEELBLUE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_TAN					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_TEAL					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_THISTLE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_TOMATO					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_TURQUOISE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_VIOLET					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_WHEAT					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_WHITE					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_WHITESMOKE				;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_YELLOW					;
XTOOLBOX_API extern const VString kCSS_XML_COLOR_YELLOWGREEN			;



//predefined color values

#define CSSMakeARGB(red,green,blue)	((((uLONG)255)<<24) | (((uLONG)red)<<16) | (((uLONG)green)<<8) | ((uLONG)blue))

#define kCSS_COLOR_ALICEBLUE				CSSMakeARGB(240, 248, 255) 
#define kCSS_COLOR_ANTIQUEWHITE				CSSMakeARGB(250, 235, 215) 
#define kCSS_COLOR_AQUA						CSSMakeARGB( 0, 255, 255) 
#define kCSS_COLOR_AQUAMARINE				CSSMakeARGB(127, 255, 212) 
#define kCSS_COLOR_AZURE					CSSMakeARGB(240, 255, 255) 
#define kCSS_COLOR_BEIGE					CSSMakeARGB(245, 245, 220) 
#define kCSS_COLOR_BISQUE					CSSMakeARGB(255, 228, 196) 
#define kCSS_COLOR_BLACK					CSSMakeARGB( 0, 0, 0) 
#define kCSS_COLOR_BLANCHEDALMOND			CSSMakeARGB(255, 235, 205) 
#define kCSS_COLOR_BLUE						CSSMakeARGB( 0, 0, 255) 
#define kCSS_COLOR_BLUEVIOLET				CSSMakeARGB(138, 43, 226) 
#define kCSS_COLOR_BROWN					CSSMakeARGB(165, 42, 42) 
#define kCSS_COLOR_BURLYWOOD				CSSMakeARGB(222, 184, 135) 
#define kCSS_COLOR_CADETBLUE				CSSMakeARGB( 95, 158, 160) 
#define kCSS_COLOR_CHARTREUSE				CSSMakeARGB(127, 255, 0) 
#define kCSS_COLOR_CHOCOLATE				CSSMakeARGB(210, 105, 30) 
#define kCSS_COLOR_CORAL					CSSMakeARGB(255, 127, 80) 
#define kCSS_COLOR_CORNFLOWERBLUE			CSSMakeARGB(100, 149, 237) 
#define kCSS_COLOR_CORNSILK					CSSMakeARGB(255, 248, 220) 
#define kCSS_COLOR_CRIMSON					CSSMakeARGB(220, 20, 60) 
#define kCSS_COLOR_CYAN						CSSMakeARGB( 0, 255, 255) 
#define kCSS_COLOR_DARKBLUE					CSSMakeARGB( 0, 0, 139) 
#define kCSS_COLOR_DARKCYAN					CSSMakeARGB( 0, 139, 139) 
#define kCSS_COLOR_DARKGOLDENROD			CSSMakeARGB(184, 134, 11) 
#define kCSS_COLOR_DARKGRAY					CSSMakeARGB(169, 169, 169) 
#define kCSS_COLOR_DARKGREEN				CSSMakeARGB( 0, 100, 0) 
#define kCSS_COLOR_DARKGREY					CSSMakeARGB(169, 169, 169) 
#define kCSS_COLOR_DARKKHAKI				CSSMakeARGB(189, 183, 107) 
#define kCSS_COLOR_DARKMAGENTA				CSSMakeARGB(139, 0, 139) 
#define kCSS_COLOR_DARKOLIVEGREEN			CSSMakeARGB( 85, 107, 47) 
#define kCSS_COLOR_DARKORANGE				CSSMakeARGB(255, 140, 0) 
#define kCSS_COLOR_DARKORCHID				CSSMakeARGB(153, 50, 204) 
#define kCSS_COLOR_DARKRED					CSSMakeARGB(139, 0, 0) 
#define kCSS_COLOR_DARKSALMON				CSSMakeARGB(233, 150, 122) 
#define kCSS_COLOR_DARKSEAGREEN				CSSMakeARGB(143, 188, 143) 
#define kCSS_COLOR_DARKSLATEBLUE			CSSMakeARGB( 72, 61, 139) 
#define kCSS_COLOR_DARKSLATEGRAY			CSSMakeARGB( 47, 79, 79) 
#define kCSS_COLOR_DARKSLATEGREY			CSSMakeARGB( 47, 79, 79) 
#define kCSS_COLOR_DARKTURQUOISE			CSSMakeARGB( 0, 206, 209) 
#define kCSS_COLOR_DARKVIOLET				CSSMakeARGB(148, 0, 211) 
#define kCSS_COLOR_DEEPPINK					CSSMakeARGB(255, 20, 147) 
#define kCSS_COLOR_DEEPSKYBLUE				CSSMakeARGB( 0, 191, 255) 
#define kCSS_COLOR_DIMGRAY					CSSMakeARGB(105, 105, 105) 
#define kCSS_COLOR_DIMGREY					CSSMakeARGB(105, 105, 105) 
#define kCSS_COLOR_DODGERBLUE				CSSMakeARGB( 30, 144, 255) 
#define kCSS_COLOR_FIREBRICK				CSSMakeARGB(178, 34, 34) 
#define kCSS_COLOR_FLORALWHITE				CSSMakeARGB(255, 250, 240) 
#define kCSS_COLOR_FORESTGREEN				CSSMakeARGB( 34, 139, 34) 
#define kCSS_COLOR_FUCHSIA					CSSMakeARGB(255, 0, 255) 
#define kCSS_COLOR_GAINSBORO				CSSMakeARGB(220, 220, 220) 
#define kCSS_COLOR_GHOSTWHITE				CSSMakeARGB(248, 248, 255) 
#define kCSS_COLOR_GOLD						CSSMakeARGB(255, 215, 0) 
#define kCSS_COLOR_GOLDENROD				CSSMakeARGB(218, 165, 32) 
#define kCSS_COLOR_GRAY						CSSMakeARGB(128, 128, 128) 
#define kCSS_COLOR_GREY						CSSMakeARGB(128, 128, 128) 
#define kCSS_COLOR_GREEN					CSSMakeARGB( 0, 128, 0) 
#define kCSS_COLOR_GREENYELLOW				CSSMakeARGB(173, 255, 47) 
#define kCSS_COLOR_HONEYDEW					CSSMakeARGB(240, 255, 240) 
#define kCSS_COLOR_HOTPINK					CSSMakeARGB(255, 105, 180) 
#define kCSS_COLOR_INDIANRED				CSSMakeARGB(205, 92, 92) 
#define kCSS_COLOR_INDIGO					CSSMakeARGB( 75, 0, 130) 
#define kCSS_COLOR_IVORY					CSSMakeARGB(255, 255, 240) 
#define kCSS_COLOR_KHAKI					CSSMakeARGB(240, 230, 140) 
#define kCSS_COLOR_LAVENDER					CSSMakeARGB(230, 230, 250) 
#define kCSS_COLOR_LAVENDERBLUSH			CSSMakeARGB(255, 240, 245) 
#define kCSS_COLOR_LAWNGREEN				CSSMakeARGB(124, 252, 0) 
#define kCSS_COLOR_LEMONCHIFFON				CSSMakeARGB(255, 250, 205) 
#define kCSS_COLOR_LIGHTBLUE				CSSMakeARGB(173, 216, 230) 
#define kCSS_COLOR_LIGHTCORAL				CSSMakeARGB(240, 128, 128) 
#define kCSS_COLOR_LIGHTCYAN				CSSMakeARGB(224, 255, 255) 
#define kCSS_COLOR_LIGHTGOLDENRODYELLOW		CSSMakeARGB(250, 250, 210) 
#define kCSS_COLOR_LIGHTGRAY				CSSMakeARGB(211, 211, 211) 
#define kCSS_COLOR_LIGHTGREEN				CSSMakeARGB(144, 238, 144) 
#define kCSS_COLOR_LIGHTGREY				CSSMakeARGB(211, 211, 211) 
#define kCSS_COLOR_LIGHTPINK				CSSMakeARGB(255, 182, 193) 
#define kCSS_COLOR_LIGHTSALMON				CSSMakeARGB(255, 160, 122) 
#define kCSS_COLOR_LIGHTSEAGREEN			CSSMakeARGB( 32, 178, 170) 
#define kCSS_COLOR_LIGHTSKYBLUE				CSSMakeARGB(135, 206, 250) 
#define kCSS_COLOR_LIGHTSLATEGRAY			CSSMakeARGB(119, 136, 153) 
#define kCSS_COLOR_LIGHTSLATEGREY			CSSMakeARGB(119, 136, 153) 
#define kCSS_COLOR_LIGHTSTEELBLUE			CSSMakeARGB(176, 196, 222) 
#define kCSS_COLOR_LIGHTYELLOW				CSSMakeARGB(255, 255, 224) 
#define kCSS_COLOR_LIME						CSSMakeARGB( 0, 255, 0) 
#define kCSS_COLOR_LIMEGREEN				CSSMakeARGB( 50, 205, 50) 
#define kCSS_COLOR_LINEN					CSSMakeARGB(250, 240, 230) 
#define kCSS_COLOR_MAGENTA					CSSMakeARGB(255, 0, 255) 
#define kCSS_COLOR_MAROON					CSSMakeARGB(128, 0, 0) 
#define kCSS_COLOR_MEDIUMAQUAMARINE			CSSMakeARGB(102, 205, 170) 
#define kCSS_COLOR_MEDIUMBLUE				CSSMakeARGB( 0, 0, 205) 
#define kCSS_COLOR_MEDIUMORCHID				CSSMakeARGB(186, 85, 211) 
#define kCSS_COLOR_MEDIUMPURPLE				CSSMakeARGB(147, 112, 219) 
#define kCSS_COLOR_MEDIUMSEAGREEN			CSSMakeARGB( 60, 179, 113) 
#define kCSS_COLOR_MEDIUMSLATEBLUE			CSSMakeARGB(123, 104, 238) 
#define kCSS_COLOR_MEDIUMSPRINGGREEN		CSSMakeARGB( 0, 250, 154) 
#define kCSS_COLOR_MEDIUMTURQUOISE			CSSMakeARGB( 72, 209, 204) 
#define kCSS_COLOR_MEDIUMVIOLETRED			CSSMakeARGB(199, 21, 133) 
#define kCSS_COLOR_MIDNIGHTBLUE				CSSMakeARGB( 25, 25, 112) 
#define kCSS_COLOR_MINTCREAM				CSSMakeARGB(245, 255, 250) 
#define kCSS_COLOR_MISTYROSE				CSSMakeARGB(255, 228, 225) 
#define kCSS_COLOR_MOCCASIN					CSSMakeARGB(255, 228, 181) 
#define kCSS_COLOR_NAVAJOWHITE				CSSMakeARGB(255, 222, 173) 
#define kCSS_COLOR_NAVY						CSSMakeARGB( 0, 0, 128) 
#define kCSS_COLOR_OLDLACE					CSSMakeARGB(253, 245, 230) 
#define kCSS_COLOR_OLIVE					CSSMakeARGB(128, 128, 0) 
#define kCSS_COLOR_OLIVEDRAB				CSSMakeARGB(107, 142, 35) 
#define kCSS_COLOR_ORANGE					CSSMakeARGB(255, 165, 0) 
#define kCSS_COLOR_ORANGERED				CSSMakeARGB(255, 69, 0) 
#define kCSS_COLOR_ORCHID					CSSMakeARGB(218, 112, 214) 
#define kCSS_COLOR_PALEGOLDENROD			CSSMakeARGB(238, 232, 170) 
#define kCSS_COLOR_PALEGREEN				CSSMakeARGB(152, 251, 152) 
#define kCSS_COLOR_PALETURQUOISE			CSSMakeARGB(175, 238, 238) 
#define kCSS_COLOR_PALEVIOLETRED			CSSMakeARGB(219, 112, 147) 
#define kCSS_COLOR_PAPAYAWHIP				CSSMakeARGB(255, 239, 213) 
#define kCSS_COLOR_PEACHPUFF				CSSMakeARGB(255, 218, 185) 
#define kCSS_COLOR_PERU						CSSMakeARGB(205, 133, 63) 
#define kCSS_COLOR_PINK						CSSMakeARGB(255, 192, 203) 
#define kCSS_COLOR_PLUM						CSSMakeARGB(221, 160, 221) 
#define kCSS_COLOR_POWDERBLUE				CSSMakeARGB(176, 224, 230) 
#define kCSS_COLOR_PURPLE					CSSMakeARGB(128, 0, 128) 
#define kCSS_COLOR_RED						CSSMakeARGB(255, 0, 0) 
#define kCSS_COLOR_ROSYBROWN				CSSMakeARGB(188, 143, 143) 
#define kCSS_COLOR_ROYALBLUE				CSSMakeARGB( 65, 105, 225) 
#define kCSS_COLOR_SADDLEBROWN				CSSMakeARGB(139, 69, 19) 
#define kCSS_COLOR_SALMON					CSSMakeARGB(250, 128, 114) 
#define kCSS_COLOR_SANDYBROWN				CSSMakeARGB(244, 164, 96) 
#define kCSS_COLOR_SEAGREEN					CSSMakeARGB( 46, 139, 87) 
#define kCSS_COLOR_SEASHELL					CSSMakeARGB(255, 245, 238) 
#define kCSS_COLOR_SIENNA					CSSMakeARGB(160, 82, 45) 
#define kCSS_COLOR_SILVER					CSSMakeARGB(192, 192, 192) 
#define kCSS_COLOR_SKYBLUE					CSSMakeARGB(135, 206, 235) 
#define kCSS_COLOR_SLATEBLUE				CSSMakeARGB(106, 90, 205) 
#define kCSS_COLOR_SLATEGRAY				CSSMakeARGB(112, 128, 144) 
#define kCSS_COLOR_SLATEGREY				CSSMakeARGB(112, 128, 144) 
#define kCSS_COLOR_SNOW						CSSMakeARGB(255, 250, 250) 
#define kCSS_COLOR_SPRINGGREEN				CSSMakeARGB( 0, 255, 127) 
#define kCSS_COLOR_STEELBLUE				CSSMakeARGB( 70, 130, 180) 
#define kCSS_COLOR_TAN						CSSMakeARGB(210, 180, 140) 
#define kCSS_COLOR_TEAL						CSSMakeARGB( 0, 128, 128) 
#define kCSS_COLOR_THISTLE					CSSMakeARGB(216, 191, 216) 
#define kCSS_COLOR_TOMATO					CSSMakeARGB(255, 99, 71) 
#define kCSS_COLOR_TURQUOISE				CSSMakeARGB( 64, 224, 208) 
#define kCSS_COLOR_VIOLET					CSSMakeARGB(238, 130, 238) 
#define kCSS_COLOR_WHEAT					CSSMakeARGB(245, 222, 179) 
#define kCSS_COLOR_WHITE					CSSMakeARGB(255, 255, 255) 
#define kCSS_COLOR_WHITESMOKE				CSSMakeARGB(245, 245, 245) 
#define kCSS_COLOR_YELLOW					CSSMakeARGB(255, 255, 0) 
#define kCSS_COLOR_YELLOWGREEN				CSSMakeARGB(154, 205, 50) 



class XTOOLBOX_API VCSSUtil
{
   /**
    *  This class does not need to be instantiated.
    */
protected:
	VCSSUtil() { }

public:
   /**
    *  Tests whether the given character is a valid hexadecimal character.
    */
   static bool isHexadecimal( UniChar c )
   {
	  int HEXADECIMAL[4] = {0, 67043328, 126, 126};
      return c < 128 && ( ( HEXADECIMAL[c / 32] & ( 1 << ( c % 32 ) ) ) != 0 );
   }

   /**
    *  Tests whether the given character is a valid identifier start character.
    */
   static bool isIdentifierStart( UniChar c )
   {
	  int IDENTIFIER_START[4] = {0, 0, 134217726+(1<<31), 134217726};
      return c >= 128 || ( ( IDENTIFIER_START[c / 32] & ( 1 << ( c % 32 ) ) ) != 0 );
   }

   /**
    *  Tests whether the given character is a valid name character.
    */
   static bool isName( UniChar c )
   {
	  int NAME[4] = {0, 67051520, 134217726+(1<<31), 134217726};
      return c >= 128 || ( ( NAME[c / 32] & ( 1 << ( c % 32 ) ) ) != 0 );
   }

   /**
    *  Tests whether the attribute name is valid
    */
   static bool isNameAttribute( const VString& inName )
   {
	   const UniChar *c = inName.GetCPointer();
	   if (*c)
	   {
		  if (!isIdentifierStart( *c++))
			  return false;
	   }
	   else
		   return false; //string must be not empty
	   while (*c)
		  if (!isName( *c++))
			  return false;
	   return true;
   }

   /**
    *  Tests whether the given character is a valid string character.
    */
   static bool isString( UniChar c )
   {
	  int STRING[4] = {512, -133, -1, 2147483647};
      return c >= 128 || ( ( STRING[c / 32] & ( 1 << ( c % 32 ) ) ) != 0 );
   }

   /**
    *  Tests whether the given character is a valid URI character.
    */
   static bool isUri( UniChar c )
   {
	 int URI[4] = {0, -902, -1, 2147483647};
     return c >= 128 || ( ( URI[c / 32] & ( 1 << ( c % 32 ) ) ) != 0 );
   }

   /**
    *  Tests whether the given character is a valid space.
    */
   static bool isSpace( UniChar c )
   {
      if (c == 32)
		  return true;
      return ( c < 32 ) &&
            ( ( ( ( ( 1L << '\t' ) |
            ( 1L << '\n' ) |
            ( 1L << '\r' ) |
            ( 1L << '\f' ) ) >> c ) & 1L ) != 0 );
   }

   static bool isEqualNoCase( UniChar c1, UniChar c2)
   {
	 if (c1 < 128)
		 if (c1 >= 'A' && c1 <= 'Z')
			 c1 += 'a'-'A';

	 return c1 == c2;
   }

   static UniChar HexaToDecimal( UniChar c)
   {
	   if (c >= 'a')
		   c = 10 + c -'a';
	   else if (c >= 'A')
		   c = 10 + c -'A';
	   else if (c >= '0')
		   c = c - '0';
	   return c;
   }

   	/** parse color component 
	@param inColorComponent
		string with [0..255] decimal value or percentage value
	@param outDecimal
		[0..255] decimal value **/
	static bool ParseColorComponentValue( const VString& inColorComponent, Real& outDecimal); 

	/** parse CSS color value 
	@param inColorCSS
		CSS color value as string
	@param outColorARGB
		decoded color as uLONG packed ARGB 
		(use VColor::FromRGBAColor with outColorARGB to build VColor from outColor)
	*/
	static bool ParseColor( const VString& inColorCSS, uLONG *outColorARGB);

	/** parse CSS color ident */
	static bool ParseColorIdent( const VString& inColorCSS, uLONG *outColorARGB);

	/** parse CSS hexadecimal color */
	static bool ParseColorHexa( const VString& inColorCSS, uLONG *outColorARGB);

	//parse a list of string values separated by either comma, space, tab, line feed or carriage return;
	//if inCount > 0 return false if output list does not contain inCount values 
	static bool ParseValueList( const VString& inText, std::vector<VString>& outValues, sLONG inCount = 0);

	//parse a list of string values separated by the specified delimiter character;
	//remove leading and trailing whitespaces from parsed values;
	//if inCount > 0 return false if output list does not contain inCount values  
	static bool ParseValueListDelim( const VString& inText, std::vector<VString>& outValues, UniChar inDelim, sLONG inCount = 0);

};


typedef struct CSSLexParserContext
{
	int fCurTokenLine;
	int fCurTokenColumn;
	int fLine;
	int fColumn;
	int fTabSize;
	bool fEOF;
	const UniChar *fCurPos;
	UniChar fCurChar;
	CSSToken::eCSSToken fCurToken;
	VString fCurTokenValue;
	Real fCurTokenValueNumber;
	VString fCurTokenValueIdent;
	bool fCurTokenString1;
	bool fCurTokenString2;
	VString fCurTokenDumpValue;
	bool fHasCurTokenLineEnding;
	bool fParsePseudoClass;

} CSSLexParserContext;

class XTOOLBOX_API VCSSLexParser : public VObject
{
public:
	VCSSLexParser( int inTabSize = 4) { fTabSize = 4; }
	virtual ~VCSSLexParser() {}

	/** start lexical parsing */
	void Start( const UniChar *inSource);

	/** step to next token and return token	*/
	CSSToken::eCSSToken Next(bool inSkipSpacesComment = true);

	/** return current token */
	CSSToken::eCSSToken GetCurToken() const;

	/** return current token value 
	@remark
		return meaningful string value so for instance:
		for CSSToken::HASH it is the hash name without the # character
		for CSSToken::ATKEYWORD it is the keyword without the @ character
		for CSSToken::STRING it is the string without brackets if any
		etc...
	*/
	const VString& GetCurTokenValue() const;

	/** get current token dump value 
	@remark 
		return string value as it is parsed so for instance:
		for CSSToken::HASH it is #{name} including # character
		for CSSToken::ATKEYWORD it is @{string} including @ character
		for CSSToken::STRING it is {string} including brackets
	*/
	const VString& GetCurTokenDumpValue();

	/** get parsed number if token is NUMBER, DIMENSION or PERCENTAGE */
	Real GetCurTokenValueNumber() const
	{
		return fCurTokenValueNumber;
	}

	/** get parsed ident if token is DIMENSION or "%" if token is PERCENTAGE */
	const VString& GetCurTokenValueIdent() const
	{
		return fCurTokenValueIdent;
	}

	/** return current line */
	int GetCurLine() const
	{
		return fCurTokenLine;
	}
	/** return current column */
	int GetCurColumn() const
	{
		return fCurTokenColumn;
	}

	/** true if cur token contains one or more line endings */
	bool HasCurTokenLineEnding() const
	{
		return fCurToken == CSSToken::S && fHasCurTokenLineEnding;
	}

	/** set current tab size */
	void SetTabSize( int inTabSize)
	{
		fTabSize = inTabSize;
	}

	/** enable/disable pseudo-class parsing 
	@remarks
		pseudo-class parsing is disabled while parsing declarations
	*/
	void ParsePseudoClass( bool inParse)
	{
		fParsePseudoClass = inParse;
	}

	/** concat current token dump value with input value */
	void ConcatCurTokenDumpValue( VString& ioValue);

	/** save parser context */
	void SaveContext();

	/** restore parser context */
	void RestoreContext();

protected:
	/** return next character or 0 for EOF 
	@remark
		skip '\r' character 
	*/
	UniChar _NextChar();

	/** parse " bracketed string */
	void _ParseString1()
	{
		_parseString( (UniChar)'"');
	}

	/** parse ' bracketed string */
	void _ParseString2()
	{
		_parseString( (UniChar)'\'');
	}

	/** parse number */
	void _parseNumber();

	/** parse escape sequence */
	UniChar _ParseEscape();

	/** parse string delimited by inCharBracket character */
	void _parseString(UniChar inCharBracket);

	/** skip spaces and comment */
	void _skipSpaces( bool inSkipComment = false);

	//** parse comment (current char is char after starting /*)
	void _parseComment(bool inSkip = false);

	/** read buffer */
	const UniChar *fSource;

	/** cur token line */
	int fCurTokenLine;

	/** cur token column */
	int fCurTokenColumn;

	/** cur char line */
	int fLine;

	/** cur char column */
	int fColumn;

	/** cur tab size */
	int fTabSize;

	/** true if end of read buffer */
	bool fEOF;

	/** current read position */
	const UniChar *fCurPos;

	/** current read character */
	UniChar fCurChar;

	/** current token key */
	CSSToken::eCSSToken fCurToken;

	/** current token string value 
	@remark
		meaningful value so for instance:
		 for CSSToken::HASH it is the hash name without the # character
		 for CSSToken::ATKEYWORD it is the keyword without the @ character
		 for CSSToken::STRING it is the string without brackets if any
		 etc...
	*/
	VString fCurTokenValue;

	/** parsed number if token is NUMBER, DIMENSION or PERCENTAGE */
	Real fCurTokenValueNumber;
	/** parsed ident if token is DIMENSION or "%" if token is PERCENTAGE */
	VString fCurTokenValueIdent;

	/** return true is current token is CSSToken::STRING | CSSToken::URI and string is bracketed with " */
	bool fCurTokenString1;
	/** return true is current token is CSSToken::STRING | CSSToken::URI and string is bracketed with ' */
	bool fCurTokenString2;

	/** token dump value 
	@remark
		internal usage only 
	*/
	VString fCurTokenDumpValue;

	bool fHasCurTokenLineEnding;

	bool fParsePseudoClass;

	CSSLexParserContext fContext;
};


/** media filter type definition */
namespace CSSMedia
{
	const VString kALL		= CVSTR("all");
	const VString kSCREEN	= CVSTR("screen");
	const VString kPRINT	= CVSTR("print");

	typedef enum eMediaType
	{
		ALL,
		SCREEN,
		PRINT
	} eMediaType;

	typedef std::set<int> Set;
	typedef std::vector<CSSMedia::Set> Stack;
}


/** CSSRuleSet type definitions
@remark
	for instance consider complex selector:

	.foo B:first-child > C[object="item"][errorLevel~="warning"][errorLevel~="error"] + D:lang(en)

	Selector instance will contain:
	{ "", { {"class", {"foo"}, true, false, true} }, DESCENDANT, {}, ""},
	{ "B", {}, DESCENDANT, {Pseudo::PC_FIRST_CHILD}, "" },
	{ "C", 
	  {
			{ "object", {"item"}, false, false, false},
			{ "errorLevel", {"warning","error"}, true, false, false }			
	  },
	  CHILD,
	  {},
	  ""
	},
	{ "D", {}, ADJACENT, {Pseudo::PC_LANG}, "en" },

*/
namespace CSSRuleSet
{
	/** selector combinators */
	typedef enum eCombinator
	{
		DESCENDANT,
		CHILD,
		ADJACENT
	} eCombinator;

	/** selector attribute condition class */
	class Condition 
	{
	public:
		VString fName;					//attribute name
		std::vector<VString> fValues;	//attribute values
		bool fInclude;					//true if comparison is ~=
		bool fBeginsWith;				//true if comparison is |=
		bool fIsClass;					//true if .[ident} class condition 

		Condition(const VString& inName, std::vector<VString>& inValues, bool inInclude = false, bool inBeginsWith = false, bool inIsClass = false)
		{
			fName		= inName;
			fValues		= inValues;
			fInclude	= inInclude;
			fBeginsWith	= inBeginsWith;
			fIsClass	= inIsClass;
		}
		Condition( const Condition& inCond)
		{
			*this = inCond;
		}
		Condition& operator=( const Condition& inCond)
		{
			if (this == &inCond)
				return *this;
			fName		= inCond.fName;
			fValues		= inCond.fValues;
			fInclude	= inCond.fInclude;
			fBeginsWith	= inCond.fBeginsWith;
			fIsClass	= inCond.fIsClass;

			return *this;
		}
		bool operator==( const Condition& inCond)
		{
			if (this == &inCond)
				return true;
			return fName.EqualToString( inCond.fName, false);
		}
		bool operator!=( const Condition& inCond)
		{
			return (!(*this == inCond));
		}
	};
	
	/** selector attribute condition vector */
	typedef std::vector<Condition> CondVector; 

	/** pseudo-class enumeration */
	namespace Pseudo
	{
		typedef enum eClass
		{
			PC_FIRST_CHILD,
			PC_LINK,
			PC_VISITED,
			PC_ACTIVE,
			PC_HOVER,
			PC_FOCUS,
			PC_LANG
		} eClass;

		typedef std::set<int> Set;
	}

	/** simple selector class */
	class SimpleSelector
	{
	public:
		VString fNameElem;		//element name (apply to all elements if empty)
		CondVector fConditions;	//attribute conditions
		eCombinator fCombinator;//selector combinator (used only if instance is not the first in selector list) 
		Pseudo::Set fPseudos;   //pseudo-classes if any
		VString fLangType;		//lang type if fPseudos contains LANG 
		bool fHasCondID;			//true if contains ID condition
	
		SimpleSelector(const VString& inNameElem, const CondVector& inConditions, eCombinator inCombinator = DESCENDANT, const Pseudo::Set& inPseudos = Pseudo::Set(), const VString& inLangType = "", bool inHasCondID = false)
		{
			fNameElem		= inNameElem;
			fConditions		= inConditions;
			fCombinator		= inCombinator;
			fPseudos		= inPseudos;
			fLangType		= inLangType;
			fHasCondID		= inHasCondID;
		}
		SimpleSelector( const SimpleSelector& inSimple)
		{
			*this = inSimple;
		}
		SimpleSelector& operator=( const SimpleSelector& inSimple)
		{
			if (this == &inSimple)
				return *this;
			fNameElem		= inSimple.fNameElem;
			fConditions		= inSimple.fConditions;
			fCombinator		= inSimple.fCombinator;
			fPseudos		= inSimple.fPseudos;
			fLangType		= inSimple.fLangType;
			fHasCondID		= inSimple.fHasCondID;

			return *this;
		}
	};

	/** selector type definition */
	typedef std::vector<SimpleSelector> Selector;

	/** selector list type definition */
	typedef std::vector<Selector> Selectors;

	class Declaration
	{
	public:
		VString fName;		//attribute ident
		VString fValue;		//attribute value/expression string-encoded
		CSSProperty::Value *fValueParsed;	//pre-parsed value 
		bool fIsImportant;  //true if declaration is important

		Declaration(const VString& inName, const VString& inValue, bool inIsImportant = false)
		{
			fName			= inName;
			fValue			= inValue;
			fValueParsed	= NULL;
			fIsImportant	= inIsImportant;
		}
		Declaration(const VString& inName, const VString& inValue, CSSProperty::Value *inValueParsed, bool inIsImportant = false)
		{
			fName			= inName;
			fValue			= inValue;
			if (inValueParsed)
				inValueParsed->Retain();
			fValueParsed	= inValueParsed;
			fIsImportant	= inIsImportant;
		}

		Declaration( const Declaration& inDeclaration)
		{
			*this = inDeclaration;
		}

		virtual ~Declaration()
		{
			XBOX::ReleaseRefCountable(&fValueParsed);
		}

		Declaration& operator=( const Declaration& inDeclaration)
		{
			if (this == &inDeclaration)
				return *this;
			fName			= inDeclaration.fName;		
			fValue			= inDeclaration.fValue;	
			if (inDeclaration.fValueParsed)
				inDeclaration.fValueParsed->Retain();
			fValueParsed	= inDeclaration.fValueParsed;
			fIsImportant	= inDeclaration.fIsImportant;	

			return *this;
		}
	};
	
	/** declaration list type definition */
	typedef std::vector<Declaration> Declarations;


	/** rule type definition */
	typedef std::pair<Selectors,Declarations> Rule;

	/** rule list type definition */
	typedef std::vector<Rule> Rules;

	/** pair <media set,rules> type definition */
	typedef std::pair<CSSMedia::Set,Rules> MediaRulesPair;

	/** media set & rules pair list type definition */
	typedef std::vector<MediaRulesPair> MediaRules;
}



/** CSS parser exception */
class XTOOLBOX_API VCSSException 
{
public:
	VCSSException( VError inError, int inLine = -1, int inColumn = -1);
	virtual ~VCSSException() {}

	/** get error code */
	VError GetError() const
	{
		return fError;
	}

	/** get error path  */
	const VString& GetErrorPath() const
	{
		return fErrorPath;
	}

	int GetLine() const { return fLine; }
	int GetColumn() const { return fColumn; }

	/** return current CSS document file name */
	static const VString& GetDocURL(); 

	/** set current CSS document file name */
	static void SetDocURL( const VString& inDocURL);
	
protected:
	/** error code */
	VError fError;

	/** error path (url+line+column) */
	VString fErrorPath;

	/** current CSS document file name */
	static VString fDocURL;

	int fLine, fColumn;
};

class XTOOLBOX_API VCSSExceptionList {
private:
	std::vector< VCSSException > fErrors;

public:
	void AddCSSException( VCSSException inErr ) { fErrors.push_back( inErr ); }
	std::vector< VCSSException > GetErrors() const { return fErrors; }
	bool HasExceptions() const { return !fErrors.empty(); }
};

/** CSS parser class definition 

@remarks
	CSS2-compliant parser

	usage:

	//init medias filter (optional: default is all)
	CSSMedia::Set medias;
	medias.insert((int)CSSMedia::ALL);

	//init rules
	CSSRuleSet::MediaRules rules;

	//run parser
	VCSSParser *parserCSS = new VCSSParser();
	try
	{
		parserCSS->ParseURL( "file:///c:/mystyles_dir/", "mystyles.css", &rules, &medias);

		//or
		//parserCSS->Parse( VString("rect { fill: red }"), "", &rules, &medias);

		//or
		//parserCSS->Parse( VString("@import url(mystyles.css); rect { fill: red }"), "file:///c:/mystyles_dir/", &rules, &medias);


	}
	catch( VCSSException e)
	{
		
		//deal with parser error
	}
	delete parserCSS;

@see 
	VCSSMatch 
*/
class XTOOLBOX_API VCSSParser : public VObject
{
public:
	VCSSParser( bool inParseAllErrors = false, int inTabSize = 4) 
	{ 
		fContinueParseAfterError = inParseAllErrors; 
		fLexParser.SetTabSize( inTabSize);
		fMapAttributeType = NULL;
	}
	virtual ~VCSSParser() {}

	/** set attribute type map 
	@remarks
		caller is map owner
	*/
	void SetMapAttributeType( const CSSProperty::MapAttributeType *inMapAttributeType)
	{
		fMapAttributeType = inMapAttributeType;
	}

	/** accessor on attribute type map by attribute name */
	const CSSProperty::MapAttributeType* MapAttributeType()
	{
		return fMapAttributeType;
	}

	/** parse CSS document from URL 
	@remarks
		document rules are added to inMediaRules
		inMedias can be used to filter with media types (all by default)
		if inBaseURLPath is not empty, last character must be a /
	*/
	void ParseURL( const VString& inBaseURLPath, const VString& inURLPath, CSSRuleSet::MediaRules *inMediaRules, CSSMedia::Set *inMedias = NULL);

	/** parse string-encoded CSS document 
	@remarks
		document rules are added to inMediaRules
		inMedias can be used to filter with media types (all by default)
		if inBaseURLPath is not empty, last character must be a /
	*/
	void Parse(  const VString& inSource, const VString& inBaseURLPath, CSSRuleSet::MediaRules *inMediaRules, CSSMedia::Set *inMedias = NULL)
	{
		VCSSException::SetDocURL("");
		_Parse( inSource, inBaseURLPath, inMediaRules, inMedias);
	}

	/** parse CSS document from UniChar buffer
	@remarks
		document rules are added to inMediaRules
		inMedias can be used to filter with media types (all by default)
		if inBaseURLPath is not empty, last character must be a /
	*/
	void Parse(  const UniChar *inSource, const VString& inBaseURLPath, CSSRuleSet::MediaRules *inMediaRules, CSSMedia::Set *inMedias = NULL)
	{
		VCSSException::SetDocURL("");
		_Parse( inSource, inBaseURLPath, inMediaRules, inMedias);
	}

	/** parse SVG URI */
	static bool ParseSVGURI( VCSSLexParser *inLexParser, VString& outURI, VString *ioValue = NULL);

	/** parse color as RGB function */
	static bool ParseRGBFunc( VCSSLexParser *inLexParser, uLONG& outColor, VString* ioValue = NULL);

	/** parse the declaration value based on the specified value type 
	@remarks
		if inParseFirstTokenOnly == false (default), parse value from all declaration value (until end of text or end of declaration token)
		otherwise parse only value from first token (useful if decalaration value is made of multiple values)
	*/
	static CSSProperty::Value *ParseValue( VCSSLexParser *inLexParser, CSSProperty::eType inType, VString* ioValue, bool inIgnoreSVG = false, bool inParseFirstTokenOnly = false);

protected:
	/** parse string-encoded CSS document 
	@remarks
		if inBaseURLPath is not empty, last character must be a /
		inMedias can be used to filter with media types (all by default)
	*/
	void _Parse(  const VString& inSource, const VString& inBaseURLPath, CSSRuleSet::MediaRules *inMediaRules, CSSMedia::Set *inMedias = NULL);

	/** parse CSS document from UniChar buffer
	@remarks
		if inBaseURLPath is not empty, last character must be a /
		inMedias can be used to filter with media types (all by default)
	*/
	void _Parse(  const UniChar *inSource, const VString& inBaseURLPath, CSSRuleSet::MediaRules *inMediaRules, CSSMedia::Set *inMedias = NULL);


	/** lexical parser */
	VCSSLexParser fLexParser;

	/** parse block */
	void _ParseBlock(bool bSkip = false);

	/** parse at-rule */
	void _ParseAtRule( const VString& inAtName);

	/** parse import rule */
	void _ParseImportRule();

	/** parse media rule */
	void _ParseMediaRule();

	/** return true if fMedia.back() contains specified media type */
	bool _MediaSetCurContains(CSSMedia::eMediaType inMediaType);

	/** return true if media set contains specified media type */
	bool _MediaSetContains(const CSSMedia::Set& inMediaTypeSet, CSSMedia::eMediaType inMediaType);

	/** return true if media set contains CSSMedia::ALL media type */
	bool _MediaSetIsAll(const CSSMedia::Set& inMediaTypeSet);

	/** parse rule-set */
	void _ParseRuleSet();

	/** parse selector */
	void _ParseSelector();

	/** parse simple selector */
	void _ParseSimpleSelector();

	/** add condition to current condition list */
	void _AddCondition( const VString& inNameAttribute, const VString& inValue, bool inInclude = false, bool inBeginsWith = false, bool inIsClass = false);

	/** parse selector attribute condition */
	void _ParseAttributeCondition();

	/** parse declarations */
	void _ParseDeclarations();

	/** concat current token value with input value */
	void _ConcatCurTokenDumpValue( VString& ioValue);
	
	/** parse value according to the specified value type */
	CSSProperty::Value *_ParseValue( CSSProperty::eType inType, VString& ioValue)
	{
		return ParseValue( &fLexParser, inType, &ioValue);
	}

	/** ref on external rulesets (classified by media type) */
	CSSRuleSet::MediaRules *fMediaRules;

	/** current ruleset */
	CSSRuleSet::Rules *fCurRules;

	/** current rule */
	CSSRuleSet::Rule *fCurRule;

	/** current selector */
	CSSRuleSet::Selector *fCurSelector;

	/** curent simple selector */
	CSSRuleSet::SimpleSelector *fCurSimpleSelector;

	/** current attribute condition list */
	CSSRuleSet::CondVector *fCurConditions;

	/** current declaration */
	CSSRuleSet::Declaration *fCurDeclaration;

	/** current simple selector combinator */
	CSSRuleSet::eCombinator fCurCombinator;

	bool fHasRules;

	/** base URL path */
	VString fBaseURL;

	/** block recursive counter */
	int fBlockCounter;

	/** media type stack */
	CSSMedia::Stack fMedia;

	/** value type map by attribute name */
	const CSSProperty::MapAttributeType *fMapAttributeType;

	bool fContinueParseAfterError;
	VCSSExceptionList fExceptionList;
};




/** CSS2 inline declarations parser class 
@remarks
	for instance "fill:red; stroke:black; stroke-width:0.1cm"

@exceptions
	might throw VCSSException
*/
class XTOOLBOX_API VCSSParserInlineDeclarations: public VObject
{
public:
	/** initialize CSS2 inline declarations parser */
	VCSSParserInlineDeclarations( bool inSilentCSSExceptions = false) { fSilentCSSExceptions = inSilentCSSExceptions; }
	virtual ~VCSSParserInlineDeclarations() {}

	/** start inline declarations parsing */
	void Start( const VString& inDeclarations);

	/** return next CSS2 attribute+value
		return false if there is none left
	*/
	bool GetNextAttribute( VString& outAttribut, VString& outValue, bool *outIsImportant = NULL);

protected:
	bool fSilentCSSExceptions;

	CSSRuleSet::Declarations fDeclarations;
	VIndex fIndexCur;
};


/** utility class for setting CSS matching attributes 
@remarks
	before starting dom/sax/custom parsing, construct instance of VCSSMatch and set all handlers 
	then while parsing, call Match() method for each element: that's all ;)
	(Match() will call SetAttribute handler only for attributes that match CSS styles)
*/
class XTOOLBOX_API VCSSMatch
{
public:
	/** opaque reference on element */
	typedef void * opaque_ElementPtr;

	/** handlers type definitions  */

	/** GetElement generic handler
	@param inElement
		element opaque reference
	@return
		element opaque reference (can be NULL)
	*/
	typedef opaque_ElementPtr(*tfn_GetElement)(opaque_ElementPtr inElement);

	/** GetElementString generic handler
	@param inElement
		element opaque reference (must be valid)
	@return
		string value
	*/
	typedef const VString&(*tfn_GetElementString)(opaque_ElementPtr inElement);

	/** GetAttributeValue handler
	@param inElement
		element opaque reference
	@param inName
		attribute name
	@param outValue
		returned attribute value
	@return 
		true if element has the attribute (in this case, outValue contains attribute value)
	*/
	typedef bool(*tfn_GetAttributeValue)(opaque_ElementPtr inElement, const VString& inName, VString& outValue);

	/** SetAttribute callback handler
		
		this callback is called by Match() for each attribute that is overridden by CSS (only one time per attribute)

	@param inElement
		element opaque reference 
	@param inName
		name of attribute to override
	@param inValue
		new value of attribute  
	@param inIsImportant
		true: always set attribute overriding existing if any
		false: only set attribute if attribute is not set yet (it does not concern inherited attributes)
	@param inValueParsed
		parsed value of attribute (NULL if value has not been parsed)
	*/
	typedef void(*tfn_SetAttribute)(opaque_ElementPtr inElement, const VString& inName, const VString& inValue, bool inIsImportant, const CSSProperty::Value* inValueParsed);

	/** initialize CSS matching class */
	VCSSMatch()
	{
		fMediaRules = NULL;
		fHandlerGetParentElement = NULL;
		fHandlerGetPrevElement = NULL;
		fHandlerGetElementName = NULL;
		fHandlerGetElementLangType = NULL;
		fHandlerGetElementClass = NULL;

		fHandlerGetAttributeValue = NULL;
		fHandlerSetAttribute = NULL;
	}

	virtual ~VCSSMatch() {}

	/** set CSS matching rules */
	void SetCSSRules( CSSRuleSet::MediaRules *inMediaRules)
	{
		fMediaRules = inMediaRules;
	}

	/** set GetParentElement handler */
	void SetHandlerGetParentElement(tfn_GetElement inHandler)
	{
		fHandlerGetParentElement = inHandler;
	}

	/** set GetPrevElement handler */
	void SetHandlerGetPrevElement(tfn_GetElement inHandler)
	{
		fHandlerGetPrevElement = inHandler;
	}

	/** set GetElementName handler */
	void SetHandlerGetElementName(tfn_GetElementString inHandler)
	{
		fHandlerGetElementName = inHandler;
	}

	/** set GetElementLangType handler */
	void SetHandlerGetElementLangType(tfn_GetElementString inHandler)
	{
		fHandlerGetElementLangType = inHandler;
	}

	/** set GetElementClass handler */
	void SetHandlerGetElementClass(tfn_GetElementString inHandler)
	{
		fHandlerGetElementClass = inHandler;
	}


	/** set GetAttributeValue handler */
	void SetHandlerGetAttributeValue(tfn_GetAttributeValue inHandler)
	{
		fHandlerGetAttributeValue = inHandler;
	}

	/** set SetAttribute handler */
	void SetHandlerSetAttribute(tfn_SetAttribute inHandler)
	{
		fHandlerSetAttribute = inHandler;
	}

	/** scan CSS rules for the specified element 
		and call fHandlerSetAttribute for any attribute that match a rule (only one time)
	@param inElement
		element opaque ref
	@param inMediaType
		media type filter (CSSMedia::ALL is default)
		(filter CSS styles with @media at-rules)
	@remarks
		all handlers must be initialized

		for now only :first-child and :lang pseudo-classes are supported; other pseudo-classes rules are ignored
	*/
	void Match(opaque_ElementPtr inElement, CSSMedia::eMediaType inMediaType = CSSMedia::ALL); 

	/** return true if inValue contains all values in inValues */
	static bool MatchInclude( const VString& inValue, const std::vector<VString>& inValues);

	/** return true if inValue contains single value inSingleValue */
	static bool MatchInclude( const VString& inValue, const VString& inSingleValue);

protected: 
	/** return true if the specified element match the specified simple selector conditions */
	bool _MatchSimpleSelector(opaque_ElementPtr inElement, const CSSRuleSet::SimpleSelector& inSimpleSelector);

	/** ref on external rulesets (classified by media type) */
	CSSRuleSet::MediaRules *fMediaRules;

	/** handlers */
	tfn_GetElement			fHandlerGetParentElement;
	tfn_GetElement			fHandlerGetPrevElement;
	tfn_GetElementString	fHandlerGetElementName;
	tfn_GetElementString	fHandlerGetElementLangType;
	tfn_GetElementString	fHandlerGetElementClass;

	tfn_GetAttributeValue	fHandlerGetAttributeValue;
	tfn_SetAttribute		fHandlerSetAttribute;
};

#define CSSClampVal(val, minval, maxval) if (val > (maxval)) val = (maxval); if ( val < (minval)) val = (minval);

END_TOOLBOX_NAMESPACE

#endif
